<!DOCTYPE html>
<html>
<head>
  <title>LibSort.js</title>
  <link rel="stylesheet" type="text/css" href="style.css" />
  <script type="text/javascript" src="../lib/libsort.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>
</head>
<body>
  <header>
    <h1>LibSort.js</h1>
  </header>
  <section id="sortSelector">
    <h2>
      Sort:
      <select id="sort">
        <option value="quicksort">
          Quicksort
        </option>
        <option value="shellsort">
          Shellsort
        </option>
        <option value="insertionsort">
          Insertion Sort
        </option>
        <option value="bubblesort">
          Bubble Sort
        </option>
      </select>
    </h2>
  </section>
  <section id="compareSection">
    <h2>Compare</h2>
    <div>
      Items: <input type="number" id="compareElements" value="100000" />
      <button onclick="doSort()">GO</button>
    </div>
    <div id="outputContainer">
      <div id="output">
        <pre name="libsortjs"></pre>
        <pre name="native"></pre>
        <pre name="debug"></pre>
      </div>
    </div>
  </section>
  <section id="visualizeSection">
    <h2>Visualize</h2>
    <div>
      Items: <input type="number" id="visualizeElements" min="0" value="100" />
      Max Delta: <input type="number" id="visualizeMaxDelta" min="-1" value="0" />
      Delay: <input type="number" id="visualizeDelay" min="0" value="0" />
      Insertion Limit: <input type="number" id="visualizeInsertionLimit" min="0" value="0" />
      Shuffle: <input type="checkbox" id="visualizeShuffle" checked />
      Reverse: <input type="checkbox" id="visualizeReverse" />
      <button onclick="doVisualize()">GO</button>
    </div>
    <div id="visualizeContainer">
      <div id="visualize"></div>
        <div id="visualizeStats">
          Array Length: <span id="visualizeStatLength">0</span>
          Comparisons: <span id="visualizeStatComparisons">0</span>
          Swaps: <span id="visualizeStatSwaps">0</span>
        </div>
    </div>
  </section>
  <script type="text/javascript">
    // console.log(quicksort([5, 3, 6, 4, 1, 2]));
    // console.log(quicksort([1, 1, 1, 1, 1, 1]));
    // console.log(quicksort([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]));
    // console.log(quicksort([1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]));

    function doVisualize() {
      const sort = document.getElementById("sort").value;

      const count = parseInt(document.getElementById("visualizeElements").value);
      const maxDelta = parseInt(document.getElementById("visualizeMaxDelta").value);
      const delay = parseInt(document.getElementById("visualizeDelay").value);
      const insertionLimit = parseInt(document.getElementById("visualizeInsertionLimit").value);
      const shuffled = document.getElementById("visualizeShuffle").checked;
      const reversed = document.getElementById("visualizeReverse").checked;
      document.getElementById("visualizeStatLength").textContent = count;
      document.getElementById("visualizeStatComparisons").textContent = "0";
      document.getElementById("visualizeStatSwaps").textContent = "0";
      const visualize = document.getElementById("visualize");
      visualize.innerHTML = "";
      const children = [];
      for (let i = 1; i <= count; i++) {
        const el = document.createElement("div");
        el.style.transform = "scaleY(" + (i / count) + ")";
        el.libSortIndex = i;
        children.push(el);
      }
      if (shuffled) shuffle(children);
      if (reversed) children.reverse();
      const frag = document.createDocumentFragment();
      for (let i = 0; i < children.length; i++) {
        frag.appendChild(children[i]);
      }
      visualize.appendChild(frag);
      window[sort](children, {
        maxDelta,
        insertionLimit,
        compareFunction: (a, b) => {
          let aOrig, bOrig;
          runInTime(() => {
            a.classList.add("compare");
            b.classList.add("compare");
            document.getElementById("visualizeStatComparisons").textContent =
              parseInt(document.getElementById("visualizeStatComparisons").textContent) + 1;
          });
          runInTime(() => {
            a.classList.remove("compare");
            b.classList.remove("compare");
          }, delay);
          if (a.libSortIndex < b.libSortIndex) return -1;
          if (a.libSortIndex > b.libSortIndex) return 1;
          return 0;
        },
        swapFunction: (arr, index1, index2) => {
          let a = arr[index1], b = arr[index2], aOrig, bOrig;
          runInTime(() => {
            a.classList.add("swap");
            b.classList.add("swap");
            document.getElementById("visualizeStatSwaps").textContent =
              parseInt(document.getElementById("visualizeStatSwaps").textContent) + 1;
          });
          runInTime(() => {
          	const temp = a.style.transform;
            a.style.transform = b.style.transform;
            b.style.transform = temp;
          }, Math.floor(delay / 2));
          runInTime(() => {
            a.classList.remove("swap");
            b.classList.remove("swap");
          }, Math.floor(delay / 2));
        	const temp = arr[index1].libSortIndex;
          arr[index1].libSortIndex = arr[index2].libSortIndex;
          arr[index2].libSortIndex = temp;
        },
        sortedCallbackFunction: (arr) => {
          runInTime(() => {
            _.forEach(arr, (el) => el.classList.add("sorted"));
          });
        }
      });
    }

    function doSort() {
      const sort = document.getElementById("sort").value;
      log("## LibSort.js " + sort, "libsortjs", true);
      log("## Native Sort", "native", true);
      log("## Checking Array Equality\n", "debug", true);

      times = {};

      const benchmarkSort = (sortFunc, shuffled, reversed, label) => {
        var arr = [...Array(parseInt(document.getElementById("compareElements").value)).keys()];
        if (shuffled) shuffle(arr);
        if (reversed) arr.reverse();
        const start = window.performance.now();
        const ret = sortFunc(arr, defaultCompareFunction);
        const end = window.performance.now();
        const time = _.round(end - start, 3);
        log("\nRun Time: " + time + "ms", label);

        if (!times[label]) times[label] = [];
        times[label].push(time);

        return ret;
      }

      let promises = [];
      runInTime(() => log("\n\n# Pre-sorted array", "libsortjs"));
      promises.push(runInTime(() => benchmarkSort(window[sort], false, false, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], false, false, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], false, false, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], false, false, "libsortjs")));
      runInTime(() => log("\n\n# Pre-sorted array", "native"));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), false, false, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), false, false, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), false, false, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), false, false, "native")));
      Promise.all(promises).then((values) => {
        let equality = true;
        _.forEach(values, (value, i) => equality = equality && (values[i+1]) ? _.isEqual(value, values[i+1]) : true);
        log("\nArray Equality: " + equality.toString(), "debug");
      });

      promises = [];
      runInTime(() => log("\n\n# Shuffled array", "libsortjs"));
      promises.push(runInTime(() => benchmarkSort(window[sort], true, false, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], true, false, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], true, false, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], true, false, "libsortjs")));
      runInTime(() => log("\n\n# Shuffled array", "native"));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), true, false, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), true, false, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), true, false, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), true, false, "native")));
      Promise.all(promises).then((values) => {
        let equality = true;
        _.forEach(values, (value, i) => equality = equality && (values[i+1]) ? _.isEqual(value, values[i+1]) : true);
        log("\nArray Equality: " + equality.toString(), "debug");
      });

      promises = [];
      runInTime(() => log("\n\n# Reversed array", "libsortjs"));
      promises.push(runInTime(() => benchmarkSort(window[sort], false, true, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], false, true, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], false, true, "libsortjs")));
      promises.push(runInTime(() => benchmarkSort(window[sort], false, true, "libsortjs")));
      runInTime(() => log("\n\n# Reversed array", "native"));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), false, true, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), false, true, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), false, true, "native")));
      promises.push(runInTime(() => benchmarkSort((arr, c) => arr.sort(c), false, true, "native")));
      Promise.all(promises).then((values) => {
        let equality = true;
        _.forEach(values, (value, i) => equality = equality && (values[i+1]) ? _.isEqual(value, values[i+1]) : true);
        log("\nArray Equality: " + equality.toString(), "debug");

        for (var label in times) {
          log("\n\n## Stats", label);
        	log("\nAverage: " + _.round(_.mean(times[label]), 3) + "ms", label);
          log("\nStd Dev: " + _.round(standardDeviation(times[label]), 3) + "ms", label);
        }
      });
    }

    let timePromise = Promise.resolve();
    function runInTime(fn, time) {
      if (!time) time = 1;
      timePromise = timePromise.then(() => {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve(fn());
          }, time);
        });
      });
      return timePromise;
    }

    function log(msg, name, clearFirst) {
    	let pre = "";
      let output = document.querySelector("#output [name=\""+name+"\"]");
    	if (!clearFirst) {
      	pre = output.innerText;
      }
      output.innerText = pre + msg;
    }

    function shuffle(array) {
      let counter = array.length;
      // While there are elements in the array
      while (counter > 0) {
        // Pick a random index
        let index = Math.floor(Math.random() * counter);
        // Decrease counter by 1
        counter--;
        // And swap the last element with it
        let temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
      }
      return array;
    }

    // from: https://derickbailey.com/2014/09/21/calculating-standard-deviation-with-array-map-and-array-reduce-in-javascript/
    function standardDeviation(values){
      var avg = average(values);

      var squareDiffs = values.map(function(value){
        var diff = value - avg;
        var sqrDiff = diff * diff;
        return sqrDiff;
      });

      var avgSquareDiff = average(squareDiffs);

      var stdDev = Math.sqrt(avgSquareDiff);
      return stdDev;
    }

    function average(data){
      var sum = data.reduce(function(sum, value){
        return sum + value;
      }, 0);

      var avg = sum / data.length;
      return avg;
    }
  </script>
</body>
</html>
